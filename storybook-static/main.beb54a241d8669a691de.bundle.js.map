{"version":3,"file":"main.beb54a241d8669a691de.bundle.js","sources":["webpack:///./packages/models/src/BagginsUpload.ts"],"sourcesContent":["import { observable, action, computed } from \"mobx\";\nimport { BagginsUploadType, NamespaceType } from \"./types\";\nimport { fromPromise, FULFILLED, PENDING } from \"mobx-utils\";\nimport { clearSpecialCharacters } from \"./utils\";\nimport Axios from \"axios\";\nimport { baggins } from \"./Baggins\";\nimport { SupportedPreviewTypes } from \"./types\";\nconst uuid = require(\"uuid\");\n// BAGGINS GUIDELINES\n\n/**\n * For *internal* access (ie, the file is being transferred to/from inside the VPN or an EC2 instance):\n 1. Test apps should target https://mcebaggins-intg.cluster.us-east-1.prod.cloud.netflix.net:7102\n 2. Prod apps should target https://mcebaggins-all.cluster.us-east-1.prod.cloud.netflix.net:7102\n For *external* users (file is leaving the VPN):\n 1. Test apps should use https://intg1.baggins.prod.netflix.net\n 2. Prod apps should use https://all.baggins.prod.netflix.net\n */\n\nconst TEST_BAGGINS_URL = \"https://intg1.baggins.prod.netflix.net\";\nconst PROD_BAGGINS_URL = \"https://all.baggins.prod.netflix.net\";\n\nexport class BagginsUpload {\n  id: string;\n  @observable tokenApiPath?: string;\n  @observable type: SupportedPreviewTypes | string;\n  @observable onSuccess: (response: any) => void;\n  @observable onFailure: (error: any) => void;\n  @observable status: any;\n  @observable uploads: any;\n  @observable completedUploads: number;\n  @observable previewUrl: string | undefined;\n  @observable bagginsToken: string | undefined;\n  @observable progress: number;\n  @observable env: any;\n  @observable namespace?: NamespaceType;\n  @observable updated: number;\n\n  constructor(props: BagginsUploadType) {\n    this.env = props.env;\n    this.id = props.id;\n    this.tokenApiPath = props.tokenApiPath;\n    this.type = props.type;\n    this.status = undefined;\n    this.bagginsToken = props.bagginsToken;\n    this.onSuccess = props.onSuccess;\n    this.onFailure = props.onFailure;\n    this.uploads = [];\n    this.completedUploads = 0;\n    this.previewUrl = undefined;\n    this.progress = 0;\n    this.namespace = props.namespace;\n    this.updated = new Date().getTime();\n    if (props.tokenApiPath) {\n      baggins.setApiPath(props.tokenApiPath);\n    }\n  }\n\n  @computed\n  get preview() {\n    return this.previewUrl;\n  }\n\n  @computed get complete() {\n    return this.completedUploads;\n  }\n\n  @computed get uploadProgress() {\n    return this.progress;\n  }\n\n  @computed get getStatus() {\n    if (this.updated > 0) {\n      let completedUploads = 0;\n      this.uploads.forEach(upload => {\n        if (upload.status.state === FULFILLED) {\n          completedUploads = completedUploads + 1;\n          this.completedUploads = completedUploads;\n        }\n      });\n      if (this.uploads.length > 0 && completedUploads === this.uploads.length) {\n        return FULFILLED;\n      } else if (this.uploads.length > 0) {\n        return PENDING;\n      }\n    }\n\n    return undefined;\n  }\n\n  @action setNamespace = (namespace: NamespaceType) => {\n    this.namespace = namespace;\n  };\n\n  @action resetStatus() {\n    this.uploads = [];\n    this.previewUrl = undefined;\n  }\n\n  @action setPreviewUrl = (previewUrl: string) => {\n    this.previewUrl = previewUrl;\n  };\n\n  @action update = () => {\n    this.updated = new Date().getTime();\n  };\n\n  @action upload = (file: any) => {\n    if (!this.namespace) {\n      return fromPromise(\n        new Promise((accept, reject) => reject(\"No namespace specified\"))\n      );\n    }\n    const isTestEnv = this.env === \"testintg\" || this.env === \"test\";\n    const isProdEnv = this.env === \"prod\" || this.env === \"alpha\";\n    const namespace = isTestEnv ? this.namespace.test : this.namespace.prod;\n    console.log({ file });\n    const normalizedFilename = `${uuid()}-${clearSpecialCharacters(file.name)}`;\n    let bagginsUrl = TEST_BAGGINS_URL;\n    if (isProdEnv) {\n      bagginsUrl = PROD_BAGGINS_URL;\n    }\n\n    const token = this.bagginsToken || baggins.currentToken;\n    if (!token) {\n      return new Promise((accept, reject) => reject(\"No baggins token found.\"));\n    }\n    const uploadUrl = `${bagginsUrl}/REST/v1/object/${namespace}/${normalizedFilename}?theRing=${token}`;\n    const request = Axios.request({\n      method: \"post\",\n      url: uploadUrl,\n      data: file,\n      headers: {\n        \"content-type\": \"application/octet-stream\",\n        \"x-baggins-upload-file-length\": file.size\n      },\n      onUploadProgress: p => {\n        this.progress = p.loaded / p.total;\n      }\n    });\n\n    const status = fromPromise(\n      request\n        .then((response: any) => {\n          const res = response.data;\n          // upload success\n          if (res.success) {\n            // upload success\n            this.previewUrl = undefined;\n\n            this.onSuccess({\n              filename: file.name,\n              url: response.request.responseURL\n            });\n            return response.request.responseURL;\n          } else {\n            this.previewUrl = undefined;\n            this.onFailure(JSON.stringify(res));\n          }\n        })\n        .catch((err: any) => {\n          this.previewUrl = undefined;\n\n          this.onFailure(err);\n        })\n    );\n\n    this.uploads.push({\n      file,\n      status\n    });\n\n    this.update();\n    return status;\n  };\n\n  @action\n  static fromValue(upload: BagginsUploadType) {\n    return new BagginsUpload(upload);\n  }\n}\n"],"mappings":"AAAA","sourceRoot":""}